<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libm2k: AnalogOut</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libm2k
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">AnalogOut<div class="ingroups"><a class="el" href="group__analog.html">Analog</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains the representation of the analogical output segment.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for AnalogOut:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__analogout.png" border="0" alt="" usemap="#group____analogout"/>
<map name="group____analogout" id="group____analogout">
<area shape="rect"  href="group__analog.html" title="Contains all analogical components." alt="" coords="5,5,72,31"/>
<area shape="rect"  title="Contains the representation of the analogical output segment." alt="" coords="120,5,211,31"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibm2k_1_1analog_1_1_m2k_analog_out.html">libm2k::analog::M2kAnalogOut</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the analogical output compound.  <a href="classlibm2k_1_1analog_1_1_m2k_analog_out.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7fc2bdfad8ddd3da510c09353f45d477"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga7fc2bdfad8ddd3da510c09353f45d477">libm2k::analog::M2kAnalogOut::getOversamplingRatio</a> ()=0</td></tr>
<tr class="memdesc:ga7fc2bdfad8ddd3da510c09353f45d477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the global oversampling ratio.  <a href="#ga7fc2bdfad8ddd3da510c09353f45d477">More...</a><br /></td></tr>
<tr class="separator:ga7fc2bdfad8ddd3da510c09353f45d477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad685eb3445f3cf4b5712385a8e58df84"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gad685eb3445f3cf4b5712385a8e58df84">libm2k::analog::M2kAnalogOut::getOversamplingRatio</a> (unsigned int chn)=0</td></tr>
<tr class="memdesc:gad685eb3445f3cf4b5712385a8e58df84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the oversampling ratio for the given channel.  <a href="#gad685eb3445f3cf4b5712385a8e58df84">More...</a><br /></td></tr>
<tr class="separator:gad685eb3445f3cf4b5712385a8e58df84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe34faa439ccf011673c5f1ddcc387e7"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gabe34faa439ccf011673c5f1ddcc387e7">libm2k::analog::M2kAnalogOut::setOversamplingRatio</a> (std::vector&lt; int &gt; oversampling_ratio)=0</td></tr>
<tr class="memdesc:gabe34faa439ccf011673c5f1ddcc387e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the oversampling ratio for each channel.  <a href="#gabe34faa439ccf011673c5f1ddcc387e7">More...</a><br /></td></tr>
<tr class="separator:gabe34faa439ccf011673c5f1ddcc387e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b50d86fc115feb46fdfe43ca2a1cb3b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga2b50d86fc115feb46fdfe43ca2a1cb3b">libm2k::analog::M2kAnalogOut::setOversamplingRatio</a> (unsigned int chn, int oversampling_ratio)=0</td></tr>
<tr class="memdesc:ga2b50d86fc115feb46fdfe43ca2a1cb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the oversampling ratio for the given channel.  <a href="#ga2b50d86fc115feb46fdfe43ca2a1cb3b">More...</a><br /></td></tr>
<tr class="separator:ga2b50d86fc115feb46fdfe43ca2a1cb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca7b9d1a5cf40b2d1065e679341cb1c1"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gaca7b9d1a5cf40b2d1065e679341cb1c1">libm2k::analog::M2kAnalogOut::getSampleRate</a> ()=0</td></tr>
<tr class="memdesc:gaca7b9d1a5cf40b2d1065e679341cb1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the sample rate of both DACs.  <a href="#gaca7b9d1a5cf40b2d1065e679341cb1c1">More...</a><br /></td></tr>
<tr class="separator:gaca7b9d1a5cf40b2d1065e679341cb1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f184574f3be74ebd54822b1d16d7383"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga9f184574f3be74ebd54822b1d16d7383">libm2k::analog::M2kAnalogOut::getSampleRate</a> (unsigned int chn)=0</td></tr>
<tr class="memdesc:ga9f184574f3be74ebd54822b1d16d7383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the sample rate for the given channel.  <a href="#ga9f184574f3be74ebd54822b1d16d7383">More...</a><br /></td></tr>
<tr class="separator:ga9f184574f3be74ebd54822b1d16d7383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba62dc41d9bb4ca38c4434dce47b7b5d"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gaba62dc41d9bb4ca38c4434dce47b7b5d">libm2k::analog::M2kAnalogOut::getAvailableSampleRates</a> (unsigned int chn)=0</td></tr>
<tr class="memdesc:gaba62dc41d9bb4ca38c4434dce47b7b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">getAvailableSampleRates  <a href="#gaba62dc41d9bb4ca38c4434dce47b7b5d">More...</a><br /></td></tr>
<tr class="separator:gaba62dc41d9bb4ca38c4434dce47b7b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab34bd111c55ed24ee4d49e26311794c4"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gab34bd111c55ed24ee4d49e26311794c4">libm2k::analog::M2kAnalogOut::setSampleRate</a> (std::vector&lt; double &gt; samplerates)=0</td></tr>
<tr class="memdesc:gab34bd111c55ed24ee4d49e26311794c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sample rate for both channels.  <a href="#gab34bd111c55ed24ee4d49e26311794c4">More...</a><br /></td></tr>
<tr class="separator:gab34bd111c55ed24ee4d49e26311794c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ce57f056e85fe9d58067fb8ceca21f"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga84ce57f056e85fe9d58067fb8ceca21f">libm2k::analog::M2kAnalogOut::setSampleRate</a> (unsigned int chn, double samplerate)=0</td></tr>
<tr class="memdesc:ga84ce57f056e85fe9d58067fb8ceca21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sample rate for the given channel.  <a href="#ga84ce57f056e85fe9d58067fb8ceca21f">More...</a><br /></td></tr>
<tr class="separator:ga84ce57f056e85fe9d58067fb8ceca21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ac70a9f0efd26bc46f01a8c6e7f371"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga65ac70a9f0efd26bc46f01a8c6e7f371">libm2k::analog::M2kAnalogOut::setCyclic</a> (bool en)=0</td></tr>
<tr class="memdesc:ga65ac70a9f0efd26bc46f01a8c6e7f371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the cyclic mode for all digital channels.  <a href="#ga65ac70a9f0efd26bc46f01a8c6e7f371">More...</a><br /></td></tr>
<tr class="separator:ga65ac70a9f0efd26bc46f01a8c6e7f371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fabc8b94b3874d6aff5a573fa4de5d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga8fabc8b94b3874d6aff5a573fa4de5d5">libm2k::analog::M2kAnalogOut::setCyclic</a> (unsigned int chn, bool en)=0</td></tr>
<tr class="memdesc:ga8fabc8b94b3874d6aff5a573fa4de5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the cyclic mode for all digital channels.  <a href="#ga8fabc8b94b3874d6aff5a573fa4de5d5">More...</a><br /></td></tr>
<tr class="separator:ga8fabc8b94b3874d6aff5a573fa4de5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac89e8a228fbf71a302b5d2e085fa8c25"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gac89e8a228fbf71a302b5d2e085fa8c25">libm2k::analog::M2kAnalogOut::getCyclic</a> (unsigned int chn)=0</td></tr>
<tr class="memdesc:gac89e8a228fbf71a302b5d2e085fa8c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of the cyclic mode.  <a href="#gac89e8a228fbf71a302b5d2e085fa8c25">More...</a><br /></td></tr>
<tr class="separator:gac89e8a228fbf71a302b5d2e085fa8c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac220f9211474aa280cf5cd505a2bedbc"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gac220f9211474aa280cf5cd505a2bedbc">libm2k::analog::M2kAnalogOut::getScalingFactor</a> (unsigned int chn)=0</td></tr>
<tr class="memdesc:gac220f9211474aa280cf5cd505a2bedbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the scaling factor for the given channel.  <a href="#gac220f9211474aa280cf5cd505a2bedbc">More...</a><br /></td></tr>
<tr class="separator:gac220f9211474aa280cf5cd505a2bedbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3002c9ea4c24af64670da2018983c3dc"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga3002c9ea4c24af64670da2018983c3dc">libm2k::analog::M2kAnalogOut::getFilterCompensation</a> (double samplerate)=0</td></tr>
<tr class="memdesc:ga3002c9ea4c24af64670da2018983c3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the filter compensation for the given sample rate.  <a href="#ga3002c9ea4c24af64670da2018983c3dc">More...</a><br /></td></tr>
<tr class="separator:ga3002c9ea4c24af64670da2018983c3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b5b04c46fbaea5417174cc1b840095d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga4b5b04c46fbaea5417174cc1b840095d">libm2k::analog::M2kAnalogOut::pushBytes</a> (unsigned int chnIdx, double *data, unsigned int nb_samples)=0</td></tr>
<tr class="memdesc:ga4b5b04c46fbaea5417174cc1b840095d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the samples to the given channel.  <a href="#ga4b5b04c46fbaea5417174cc1b840095d">More...</a><br /></td></tr>
<tr class="separator:ga4b5b04c46fbaea5417174cc1b840095d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e5f65bb4a93b4a6a8281aef6f37245c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga7e5f65bb4a93b4a6a8281aef6f37245c">libm2k::analog::M2kAnalogOut::pushRawBytes</a> (unsigned int chnIdx, short *data, unsigned int nb_samples)=0</td></tr>
<tr class="memdesc:ga7e5f65bb4a93b4a6a8281aef6f37245c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the samples to the given channel.  <a href="#ga7e5f65bb4a93b4a6a8281aef6f37245c">More...</a><br /></td></tr>
<tr class="separator:ga7e5f65bb4a93b4a6a8281aef6f37245c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad130d87c90f18e68174beb50bebea18d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gad130d87c90f18e68174beb50bebea18d">libm2k::analog::M2kAnalogOut::pushInterleaved</a> (double *data, unsigned int nb_channels, unsigned int nb_samples)=0</td></tr>
<tr class="memdesc:gad130d87c90f18e68174beb50bebea18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send samples to all the channels.  <a href="#gad130d87c90f18e68174beb50bebea18d">More...</a><br /></td></tr>
<tr class="separator:gad130d87c90f18e68174beb50bebea18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0973fbe8f043a37d2e0da5828d018073"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga0973fbe8f043a37d2e0da5828d018073">libm2k::analog::M2kAnalogOut::pushRawInterleaved</a> (short *data, unsigned int nb_channels, unsigned int nb_samples)=0</td></tr>
<tr class="memdesc:ga0973fbe8f043a37d2e0da5828d018073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send samples to all the channels.  <a href="#ga0973fbe8f043a37d2e0da5828d018073">More...</a><br /></td></tr>
<tr class="separator:ga0973fbe8f043a37d2e0da5828d018073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8323899b9f5ea25d9213612471d4c63b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga8323899b9f5ea25d9213612471d4c63b">libm2k::analog::M2kAnalogOut::push</a> (unsigned int chnIdx, std::vector&lt; double &gt; const &amp;data)=0</td></tr>
<tr class="memdesc:ga8323899b9f5ea25d9213612471d4c63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the samples to the given channel.  <a href="#ga8323899b9f5ea25d9213612471d4c63b">More...</a><br /></td></tr>
<tr class="separator:ga8323899b9f5ea25d9213612471d4c63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f8e633ba25848e84db9bedb9bef58da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga9f8e633ba25848e84db9bedb9bef58da">libm2k::analog::M2kAnalogOut::pushRaw</a> (unsigned int chnIdx, std::vector&lt; short &gt; const &amp;data)=0</td></tr>
<tr class="memdesc:ga9f8e633ba25848e84db9bedb9bef58da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the samples to the given channel.  <a href="#ga9f8e633ba25848e84db9bedb9bef58da">More...</a><br /></td></tr>
<tr class="separator:ga9f8e633ba25848e84db9bedb9bef58da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe26dfdb24af3beac4de93529410408"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga5fe26dfdb24af3beac4de93529410408">libm2k::analog::M2kAnalogOut::push</a> (std::vector&lt; std::vector&lt; double &gt;&gt; const &amp;data)=0</td></tr>
<tr class="memdesc:ga5fe26dfdb24af3beac4de93529410408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send samples to channels.  <a href="#ga5fe26dfdb24af3beac4de93529410408">More...</a><br /></td></tr>
<tr class="separator:ga5fe26dfdb24af3beac4de93529410408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a7e23ea9992a48e644fbdd461fe4c61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga6a7e23ea9992a48e644fbdd461fe4c61">libm2k::analog::M2kAnalogOut::pushRaw</a> (std::vector&lt; std::vector&lt; short &gt;&gt; const &amp;data)=0</td></tr>
<tr class="memdesc:ga6a7e23ea9992a48e644fbdd461fe4c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send samples to channels.  <a href="#ga6a7e23ea9992a48e644fbdd461fe4c61">More...</a><br /></td></tr>
<tr class="separator:ga6a7e23ea9992a48e644fbdd461fe4c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb08074cdda7f6fb407a2dfc0193efb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga8fb08074cdda7f6fb407a2dfc0193efb">libm2k::analog::M2kAnalogOut::stop</a> ()=0</td></tr>
<tr class="memdesc:ga8fb08074cdda7f6fb407a2dfc0193efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop all channels from sending the signals.  <a href="#ga8fb08074cdda7f6fb407a2dfc0193efb">More...</a><br /></td></tr>
<tr class="separator:ga8fb08074cdda7f6fb407a2dfc0193efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0087d48359470e8d7f0aaffe42b485e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga0087d48359470e8d7f0aaffe42b485e1">libm2k::analog::M2kAnalogOut::stop</a> (unsigned int chn)=0</td></tr>
<tr class="memdesc:ga0087d48359470e8d7f0aaffe42b485e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the given channels from sending the signals.  <a href="#ga0087d48359470e8d7f0aaffe42b485e1">More...</a><br /></td></tr>
<tr class="separator:ga0087d48359470e8d7f0aaffe42b485e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e08834b2c91d62f3c6f8773e8a496f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gab3e08834b2c91d62f3c6f8773e8a496f">libm2k::analog::M2kAnalogOut::cancelBuffer</a> ()=0</td></tr>
<tr class="memdesc:gab3e08834b2c91d62f3c6f8773e8a496f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all buffer operations of enabled channels.  <a href="#gab3e08834b2c91d62f3c6f8773e8a496f">More...</a><br /></td></tr>
<tr class="separator:gab3e08834b2c91d62f3c6f8773e8a496f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3898d232a908a35e3ead630fcb367ad6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga3898d232a908a35e3ead630fcb367ad6">libm2k::analog::M2kAnalogOut::cancelBuffer</a> (unsigned int chn)=0</td></tr>
<tr class="memdesc:ga3898d232a908a35e3ead630fcb367ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all buffer operations of the given channel.  <a href="#ga3898d232a908a35e3ead630fcb367ad6">More...</a><br /></td></tr>
<tr class="separator:ga3898d232a908a35e3ead630fcb367ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0293cf93f394c192f493d38d1a6f1f84"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga0293cf93f394c192f493d38d1a6f1f84">libm2k::analog::M2kAnalogOut::enableChannel</a> (unsigned int chnIdx, bool enable)=0</td></tr>
<tr class="memdesc:ga0293cf93f394c192f493d38d1a6f1f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the given digital channel.  <a href="#ga0293cf93f394c192f493d38d1a6f1f84">More...</a><br /></td></tr>
<tr class="separator:ga0293cf93f394c192f493d38d1a6f1f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373c0e1c7cf70dfc78321fc609628b5f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga373c0e1c7cf70dfc78321fc609628b5f">libm2k::analog::M2kAnalogOut::isChannelEnabled</a> (unsigned int chnIdx)=0</td></tr>
<tr class="memdesc:ga373c0e1c7cf70dfc78321fc609628b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the given channel is enabled.  <a href="#ga373c0e1c7cf70dfc78321fc609628b5f">More...</a><br /></td></tr>
<tr class="separator:ga373c0e1c7cf70dfc78321fc609628b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0141fc6a3c9c5a80d429bfca61c58d40"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga0141fc6a3c9c5a80d429bfca61c58d40">libm2k::analog::M2kAnalogOut::isPushDone</a> (unsigned int chnIdx) const =0</td></tr>
<tr class="memdesc:ga0141fc6a3c9c5a80d429bfca61c58d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the generation of the signal (only for non-cyclic buffer) is done.  <a href="#ga0141fc6a3c9c5a80d429bfca61c58d40">More...</a><br /></td></tr>
<tr class="separator:ga0141fc6a3c9c5a80d429bfca61c58d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054b4fc523c5b5fdf5f39f5b14ae94e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga054b4fc523c5b5fdf5f39f5b14ae94e7">libm2k::analog::M2kAnalogOut::setKernelBuffersCount</a> (unsigned int chnIdx, unsigned int count)=0</td></tr>
<tr class="memdesc:ga054b4fc523c5b5fdf5f39f5b14ae94e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the kernel buffers to a specific value.  <a href="#ga054b4fc523c5b5fdf5f39f5b14ae94e7">More...</a><br /></td></tr>
<tr class="separator:ga054b4fc523c5b5fdf5f39f5b14ae94e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23b330fc9204382103b5ba916d097b2f"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga23b330fc9204382103b5ba916d097b2f">libm2k::analog::M2kAnalogOut::getKernelBuffersCount</a> (unsigned int chnIdx) const =0</td></tr>
<tr class="memdesc:ga23b330fc9204382103b5ba916d097b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of kernel buffers.  <a href="#ga23b330fc9204382103b5ba916d097b2f">More...</a><br /></td></tr>
<tr class="separator:ga23b330fc9204382103b5ba916d097b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b23c10178362b1bc09e0a422c20b63"><td class="memItemLeft" align="right" valign="top">virtual short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gab5b23c10178362b1bc09e0a422c20b63">libm2k::analog::M2kAnalogOut::convertVoltsToRaw</a> (unsigned int channel, double voltage)=0</td></tr>
<tr class="memdesc:gab5b23c10178362b1bc09e0a422c20b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the volts value of a sample into raw.  <a href="#gab5b23c10178362b1bc09e0a422c20b63">More...</a><br /></td></tr>
<tr class="separator:gab5b23c10178362b1bc09e0a422c20b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada83f295802844a9d5ec5c30fc503566"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gada83f295802844a9d5ec5c30fc503566">libm2k::analog::M2kAnalogOut::convertRawToVolts</a> (unsigned int channel, short raw)=0</td></tr>
<tr class="memdesc:gada83f295802844a9d5ec5c30fc503566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the raw value of a sample into volts.  <a href="#gada83f295802844a9d5ec5c30fc503566">More...</a><br /></td></tr>
<tr class="separator:gada83f295802844a9d5ec5c30fc503566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga839474ad33fcc9f42ca6c9bb242a5076"><td class="memItemLeft" align="right" valign="top">virtual struct IIO_OBJECTS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga839474ad33fcc9f42ca6c9bb242a5076">libm2k::analog::M2kAnalogOut::getIioObjects</a> ()=0</td></tr>
<tr class="memdesc:ga839474ad33fcc9f42ca6c9bb242a5076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to IIO channels, buffers, devices and context.  <a href="#ga839474ad33fcc9f42ca6c9bb242a5076">More...</a><br /></td></tr>
<tr class="separator:ga839474ad33fcc9f42ca6c9bb242a5076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec2165e7809d9b70a856c2f31c25e33d"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gaec2165e7809d9b70a856c2f31c25e33d">libm2k::analog::M2kAnalogOut::getNbChannels</a> ()=0</td></tr>
<tr class="memdesc:gaec2165e7809d9b70a856c2f31c25e33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of analogical channels.  <a href="#gaec2165e7809d9b70a856c2f31c25e33d">More...</a><br /></td></tr>
<tr class="separator:gaec2165e7809d9b70a856c2f31c25e33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbffa76f272fc6e1ed2fc7b581f37021"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gafbffa76f272fc6e1ed2fc7b581f37021">libm2k::analog::M2kAnalogOut::getChannelName</a> (unsigned int channel)=0</td></tr>
<tr class="memdesc:gafbffa76f272fc6e1ed2fc7b581f37021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the channel name for each DAC channel.  <a href="#gafbffa76f272fc6e1ed2fc7b581f37021">More...</a><br /></td></tr>
<tr class="separator:gafbffa76f272fc6e1ed2fc7b581f37021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ede142099d6c9a5b67a42af645b7838"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga8ede142099d6c9a5b67a42af645b7838">libm2k::analog::M2kAnalogOut::getMaximumSamplerate</a> (unsigned int chn_idx)=0</td></tr>
<tr class="memdesc:ga8ede142099d6c9a5b67a42af645b7838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum samplerate for the DAC.  <a href="#ga8ede142099d6c9a5b67a42af645b7838">More...</a><br /></td></tr>
<tr class="separator:ga8ede142099d6c9a5b67a42af645b7838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe266e2ff3c51fcc6878e7e487e2b010"><td class="memItemLeft" align="right" valign="top">virtual unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gafe266e2ff3c51fcc6878e7e487e2b010">libm2k::analog::M2kAnalogOut::setVoltage</a> (unsigned int chn_idx, double volts)=0</td></tr>
<tr class="memdesc:gafe266e2ff3c51fcc6878e7e487e2b010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the voltage output of the DAC channel.  <a href="#gafe266e2ff3c51fcc6878e7e487e2b010">More...</a><br /></td></tr>
<tr class="separator:gafe266e2ff3c51fcc6878e7e487e2b010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab436c577c151a246305a83f73953f124"><td class="memItemLeft" align="right" valign="top">virtual unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#gab436c577c151a246305a83f73953f124">libm2k::analog::M2kAnalogOut::setVoltageRaw</a> (unsigned int chn_idx, unsigned short raw)=0</td></tr>
<tr class="memdesc:gab436c577c151a246305a83f73953f124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the raw output of the DAC channel.  <a href="#gab436c577c151a246305a83f73953f124">More...</a><br /></td></tr>
<tr class="separator:gab436c577c151a246305a83f73953f124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga781d66ca3fb8f129e7d08b559feab245"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classlibm2k_1_1_m2k_hardware_trigger.html">libm2k::M2kHardwareTrigger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga781d66ca3fb8f129e7d08b559feab245">libm2k::analog::M2kAnalogOut::getTrigger</a> ()=0</td></tr>
<tr class="memdesc:ga781d66ca3fb8f129e7d08b559feab245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the hardware trigger handler.  <a href="#ga781d66ca3fb8f129e7d08b559feab245">More...</a><br /></td></tr>
<tr class="separator:ga781d66ca3fb8f129e7d08b559feab245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f847f25ad78a6b0b5f007bbd30af479"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga9f847f25ad78a6b0b5f007bbd30af479">libm2k::analog::M2kAnalogOut::setBufferRearmOnTrigger</a> (bool enable)=0</td></tr>
<tr class="memdesc:ga9f847f25ad78a6b0b5f007bbd30af479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows sequential output of multiple buffers with each trigger event.  <a href="#ga9f847f25ad78a6b0b5f007bbd30af479">More...</a><br /></td></tr>
<tr class="separator:ga9f847f25ad78a6b0b5f007bbd30af479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1404f76a293f0645c1858949514ff66b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogout.html#ga1404f76a293f0645c1858949514ff66b">libm2k::analog::M2kAnalogOut::getBufferRearmOnTrigger</a> () const =0</td></tr>
<tr class="memdesc:ga1404f76a293f0645c1858949514ff66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of the attribute that controls buffer rearm on trigger.  <a href="#ga1404f76a293f0645c1858949514ff66b">More...</a><br /></td></tr>
<tr class="separator:ga1404f76a293f0645c1858949514ff66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Contains the representation of the analogical output segment. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab3e08834b2c91d62f3c6f8773e8a496f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3e08834b2c91d62f3c6f8773e8a496f">&#9670;&nbsp;</a></span>cancelBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::cancelBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all buffer operations of enabled channels. </p>
<dl class="section note"><dt>Note</dt><dd>Should be used to cancel an ongoing data write. </dd></dl>

</div>
</div>
<a id="ga3898d232a908a35e3ead630fcb367ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3898d232a908a35e3ead630fcb367ad6">&#9670;&nbsp;</a></span>cancelBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::cancelBuffer </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all buffer operations of the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The index corresponding to the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Should be used to cancel an ongoing data write. </dd></dl>

</div>
</div>
<a id="gada83f295802844a9d5ec5c30fc503566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada83f295802844a9d5ec5c30fc503566">&#9670;&nbsp;</a></span>convertRawToVolts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double libm2k::analog::M2kAnalogOut::convertRawToVolts </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>raw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the raw value of a sample into volts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The index corresponding to the channel </td></tr>
    <tr><td class="paramname">raw</td><td>The raw value of a sample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of a sample converted into volts </dd></dl>

</div>
</div>
<a id="gab5b23c10178362b1bc09e0a422c20b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5b23c10178362b1bc09e0a422c20b63">&#9670;&nbsp;</a></span>convertVoltsToRaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual short libm2k::analog::M2kAnalogOut::convertVoltsToRaw </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>voltage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the volts value of a sample into raw. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The index corresponding to the channel </td></tr>
    <tr><td class="paramname">voltage</td><td>The volts value of a sample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of a sample converted into raw </dd></dl>

</div>
</div>
<a id="ga0293cf93f394c192f493d38d1a6f1f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0293cf93f394c192f493d38d1a6f1f84">&#9670;&nbsp;</a></span>enableChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::enableChannel </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chnIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the given digital channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chnIdx</td><td>The index corresponding to the channel </td></tr>
    <tr><td class="paramname">enable</td><td>A boolean value corresponding to the channel's state</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EXC_OUT_OF_RANGE</td><td>No such channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba62dc41d9bb4ca38c4434dce47b7b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba62dc41d9bb4ca38c4434dce47b7b5d">&#9670;&nbsp;</a></span>getAvailableSampleRates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;double&gt; libm2k::analog::M2kAnalogOut::getAvailableSampleRates </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getAvailableSampleRates </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The index corresponding to the required channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of available samplerates for this device </dd></dl>

</div>
</div>
<a id="ga1404f76a293f0645c1858949514ff66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1404f76a293f0645c1858949514ff66b">&#9670;&nbsp;</a></span>getBufferRearmOnTrigger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool libm2k::analog::M2kAnalogOut::getBufferRearmOnTrigger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the value of the attribute that controls buffer rearm on trigger. </p>
<dl class="section note"><dt>Note</dt><dd>The buffer rearm on trigger is disabled by default. </dd>
<dd>
The attribute is shared between both channels. </dd>
<dd>
Only available from firmware v0.33. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value corresponding to the state of the rearm on trigger. </dd></dl>

</div>
</div>
<a id="gafbffa76f272fc6e1ed2fc7b581f37021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbffa76f272fc6e1ed2fc7b581f37021">&#9670;&nbsp;</a></span>getChannelName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string libm2k::analog::M2kAnalogOut::getChannelName </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>channel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the channel name for each DAC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>- unsigned int representing the index of the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string - name of the channel </dd></dl>

</div>
</div>
<a id="gac89e8a228fbf71a302b5d2e085fa8c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac89e8a228fbf71a302b5d2e085fa8c25">&#9670;&nbsp;</a></span>getCyclic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool libm2k::analog::M2kAnalogOut::getCyclic </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the value of the cyclic mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The index corresponding to the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value corresponding to the state of the cyclic mode </dd></dl>

</div>
</div>
<a id="ga3002c9ea4c24af64670da2018983c3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3002c9ea4c24af64670da2018983c3dc">&#9670;&nbsp;</a></span>getFilterCompensation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double libm2k::analog::M2kAnalogOut::getFilterCompensation </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>samplerate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the filter compensation for the given sample rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerate</td><td>A double value representing the sample rate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the filter compensation </dd></dl>

</div>
</div>
<a id="ga839474ad33fcc9f42ca6c9bb242a5076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga839474ad33fcc9f42ca6c9bb242a5076">&#9670;&nbsp;</a></span>getIioObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual struct IIO_OBJECTS libm2k::analog::M2kAnalogOut::getIioObjects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access to IIO channels, buffers, devices and context. </p>
<dl class="section note"><dt>Note</dt><dd>Can be used when debugging directly with libiio. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>IIO_OBJECTS structure. </dd></dl>

</div>
</div>
<a id="ga23b330fc9204382103b5ba916d097b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23b330fc9204382103b5ba916d097b2f">&#9670;&nbsp;</a></span>getKernelBuffersCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int libm2k::analog::M2kAnalogOut::getKernelBuffersCount </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chnIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of kernel buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chnIdx</td><td>The index corresponding to the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of previously set kernel buffers (saved in this session) </dd></dl>

</div>
</div>
<a id="ga8ede142099d6c9a5b67a42af645b7838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ede142099d6c9a5b67a42af645b7838">&#9670;&nbsp;</a></span>getMaximumSamplerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double libm2k::analog::M2kAnalogOut::getMaximumSamplerate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn_idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum samplerate for the DAC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn_idx</td><td>- unsigned int representing the index of the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double - the value of the maximum samplerate </dd></dl>

</div>
</div>
<a id="gaec2165e7809d9b70a856c2f31c25e33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec2165e7809d9b70a856c2f31c25e33d">&#9670;&nbsp;</a></span>getNbChannels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int libm2k::analog::M2kAnalogOut::getNbChannels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the number of analogical channels. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of channels </dd></dl>

</div>
</div>
<a id="ga7fc2bdfad8ddd3da510c09353f45d477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fc2bdfad8ddd3da510c09353f45d477">&#9670;&nbsp;</a></span>getOversamplingRatio() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int&gt; libm2k::analog::M2kAnalogOut::getOversamplingRatio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the global oversampling ratio. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of the global oversampling ratio </dd></dl>

</div>
</div>
<a id="gad685eb3445f3cf4b5712385a8e58df84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad685eb3445f3cf4b5712385a8e58df84">&#9670;&nbsp;</a></span>getOversamplingRatio() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int libm2k::analog::M2kAnalogOut::getOversamplingRatio </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the oversampling ratio for the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The index corresponding to the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The oversampling ratio value </dd></dl>

</div>
</div>
<a id="gaca7b9d1a5cf40b2d1065e679341cb1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca7b9d1a5cf40b2d1065e679341cb1c1">&#9670;&nbsp;</a></span>getSampleRate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;double&gt; libm2k::analog::M2kAnalogOut::getSampleRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the sample rate of both DACs. </p>
<dl class="section return"><dt>Returns</dt><dd>A list containing the sample rates </dd></dl>

</div>
</div>
<a id="ga9f184574f3be74ebd54822b1d16d7383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f184574f3be74ebd54822b1d16d7383">&#9670;&nbsp;</a></span>getSampleRate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double libm2k::analog::M2kAnalogOut::getSampleRate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the sample rate for the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The index corresponding to the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the sample rate </dd></dl>

</div>
</div>
<a id="gac220f9211474aa280cf5cd505a2bedbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac220f9211474aa280cf5cd505a2bedbc">&#9670;&nbsp;</a></span>getScalingFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double libm2k::analog::M2kAnalogOut::getScalingFactor </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the scaling factor for the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The index corresponding to the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the scaling factor</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EXC_OUT_OF_RANGE</td><td>No such channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga781d66ca3fb8f129e7d08b559feab245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga781d66ca3fb8f129e7d08b559feab245">&#9670;&nbsp;</a></span>getTrigger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classlibm2k_1_1_m2k_hardware_trigger.html">libm2k::M2kHardwareTrigger</a>* libm2k::analog::M2kAnalogOut::getTrigger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the hardware trigger handler. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the hardware trigger </dd></dl>

</div>
</div>
<a id="ga373c0e1c7cf70dfc78321fc609628b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373c0e1c7cf70dfc78321fc609628b5f">&#9670;&nbsp;</a></span>isChannelEnabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool libm2k::analog::M2kAnalogOut::isChannelEnabled </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chnIdx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the given channel is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chnIdx</td><td>The index corresponding to the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean value corresponding to the state of the channel</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EXC_OUT_OF_RANGE</td><td>No such channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0141fc6a3c9c5a80d429bfca61c58d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0141fc6a3c9c5a80d429bfca61c58d40">&#9670;&nbsp;</a></span>isPushDone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool libm2k::analog::M2kAnalogOut::isPushDone </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chnIdx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the generation of the signal (only for non-cyclic buffer) is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chnIdx</td><td>The index corresponding to the channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the push process is done, false otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function takes the number of kernel buffers into consideration. </dd>
<dd>
If a new session is started without unplugging the board and the number of kernel buffers was modified in the previous session </dd>
<dd>
(default value = 4) a DAC calibration must be performed before calling isPushDone in order to compute the </dd>
<dd>
current number of kernel buffers or call again the function setKernelBuffersCount.</dd>
<dd>
Available only in firmware versions newer than 0.23. </dd></dl>

</div>
</div>
<a id="ga8323899b9f5ea25d9213612471d4c63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8323899b9f5ea25d9213612471d4c63b">&#9670;&nbsp;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::push </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chnIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; const &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send the samples to the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chnIdx</td><td>The index corresponding to the channel </td></tr>
    <tr><td class="paramname">data</td><td>A list of doubles containing all samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Streaming data is possible - required multiple kernel buffers </dd>
<dd>
The given channel won't be synchronized with the other channel </dd>
<dd>
Due to a hardware limitation, the number of samples per channel must be a multiple of 4 and greater than 16 (non-cyclic buffers) or 1024 (cyclic buffers) </dd>
<dd>
The samples in the buffer can be repeated until the buffer reaches the size requirements </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EXC_OUT_OF_RANGE</td><td>No such channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5fe26dfdb24af3beac4de93529410408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fe26dfdb24af3beac4de93529410408">&#9670;&nbsp;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::push </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send samples to channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A list containing lists of samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The index of each list of samples represents the channel's index </dd>
<dd>
Streaming data is possible - required multiple kernel buffers </dd>
<dd>
The given channel won't be synchronized with the other channel </dd>
<dd>
Due to a hardware limitation, the number of samples per channel must be a multiple of 4 and greater than 16 (non-cyclic buffers) or 1024 (cyclic buffers) </dd>
<dd>
The samples in the buffer can be repeated until the buffer reaches the size requirements </dd></dl>

</div>
</div>
<a id="ga4b5b04c46fbaea5417174cc1b840095d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b5b04c46fbaea5417174cc1b840095d">&#9670;&nbsp;</a></span>pushBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::pushBytes </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chnIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nb_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send the samples to the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chnIdx</td><td>The index corresponding to the channel </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the samples </td></tr>
    <tr><td class="paramname">nb_samples</td><td>the number of samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Streaming data is possible - required multiple kernel buffers </dd>
<dd>
The given channel won't be synchronized with the other channel </dd>
<dd>
Due to a hardware limitation, the number of samples per channel must be a multiple of 4 and greater than 16 (non-cyclic buffers) or 1024 (cyclic buffers) </dd>
<dd>
The samples in the buffer can be repeated until the buffer reaches the size requirements </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EXC_OUT_OF_RANGE</td><td>No such channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad130d87c90f18e68174beb50bebea18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad130d87c90f18e68174beb50bebea18d">&#9670;&nbsp;</a></span>pushInterleaved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::pushInterleaved </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nb_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nb_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send samples to all the channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the interleaved data </td></tr>
    <tr><td class="paramname">nb_channels</td><td>the number of channels on which we want to push </td></tr>
    <tr><td class="paramname">nb_samples</td><td>the number of samples total (samples_per_channel * channels) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Make sure the samples are interleaved </dd>
<dd>
Streaming data is possible - required multiple kernel buffers </dd>
<dd>
The given channel will be synchronized with the other channel </dd>
<dd>
Due to a hardware limitation, the number of samples per channel must be a multiple of 4 and greater than 16 (non-cyclic buffers) or 1024 (cyclic buffers) </dd>
<dd>
The samples in the buffer can be repeated until the buffer reaches the size requirements </dd></dl>

</div>
</div>
<a id="ga9f8e633ba25848e84db9bedb9bef58da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f8e633ba25848e84db9bedb9bef58da">&#9670;&nbsp;</a></span>pushRaw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::pushRaw </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chnIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; short &gt; const &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send the samples to the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chnIdx</td><td>The index corresponding to the channel </td></tr>
    <tr><td class="paramname">data</td><td>A list of shorts containing all samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Streaming data is possible - required multiple kernel buffers </dd>
<dd>
The given channel won't be synchronized with the other channel </dd>
<dd>
Due to a hardware limitation, the number of samples per channel must be a multiple of 4 and greater than 16 (non-cyclic buffers) or 1024 (cyclic buffers) </dd>
<dd>
The samples in the buffer can be repeated until the buffer reaches the size requirements </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EXC_OUT_OF_RANGE</td><td>No such channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a7e23ea9992a48e644fbdd461fe4c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a7e23ea9992a48e644fbdd461fe4c61">&#9670;&nbsp;</a></span>pushRaw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::pushRaw </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; short &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send samples to channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A list containing lists of samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The index of each list of samples represents the channel's index </dd>
<dd>
Streaming data is possible - required multiple kernel buffers </dd>
<dd>
The given channel won't be synchronized with the other channel </dd>
<dd>
Due to a hardware limitation, the number of samples per channel must be a multiple of 4 and greater than 16 (non-cyclic buffers) or 1024 (cyclic buffers) </dd>
<dd>
The samples in the buffer can be repeated until the buffer reaches the size requirements </dd></dl>

</div>
</div>
<a id="ga7e5f65bb4a93b4a6a8281aef6f37245c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e5f65bb4a93b4a6a8281aef6f37245c">&#9670;&nbsp;</a></span>pushRawBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::pushRawBytes </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chnIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nb_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send the samples to the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chnIdx</td><td>The index corresponding to the channel </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the raw samples </td></tr>
    <tr><td class="paramname">nb_samples</td><td>the number of samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Streaming data is possible - required multiple kernel buffers </dd>
<dd>
The given channel won't be synchronized with the other channel </dd>
<dd>
Due to a hardware limitation, the number of samples per channel must be a multiple of 4 and greater than 16 (non-cyclic buffers) or 1024 (cyclic buffers) </dd>
<dd>
The samples in the buffer can be repeated until the buffer reaches the size requirements </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EXC_OUT_OF_RANGE</td><td>No such channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0973fbe8f043a37d2e0da5828d018073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0973fbe8f043a37d2e0da5828d018073">&#9670;&nbsp;</a></span>pushRawInterleaved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::pushRawInterleaved </td>
          <td>(</td>
          <td class="paramtype">short *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nb_channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nb_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send samples to all the channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the interleaved raw data </td></tr>
    <tr><td class="paramname">nb_channels</td><td>the number of channels on which we want to push </td></tr>
    <tr><td class="paramname">nb_samples</td><td>the number of samples total (samples_per_channel * channels) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Make sure the raw samples are interleaved </dd>
<dd>
Streaming data is possible - required multiple kernel buffers </dd>
<dd>
The given channel will be synchronized with the other channel </dd>
<dd>
Due to a hardware limitation, the number of samples per channel must be a multiple of 4 and greater than 16 (non-cyclic buffers) or 1024 (cyclic buffers) </dd>
<dd>
The samples in the buffer can be repeated until the buffer reaches the size requirements </dd></dl>

</div>
</div>
<a id="ga9f847f25ad78a6b0b5f007bbd30af479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f847f25ad78a6b0b5f007bbd30af479">&#9670;&nbsp;</a></span>setBufferRearmOnTrigger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::setBufferRearmOnTrigger </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows sequential output of multiple buffers with each trigger event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>A boolean value that enables or disables the buffer rearm functionality.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When disabled, all buffers will be sent at once. Opt to concatenate multiple small buffers into a single buffer to avoid timing problems. </dd>
<dd>
When enabled, each previously pushed buffer will be sent sequentially with each trigger event. </dd>
<dd>
For non-cyclic mode each buffer is sent only once. </dd>
<dd>
In cyclic mode:<ul>
<li>If rearm is disabled, the buffer will be sent continuously.</li>
<li>If rearm is enabled, the buffer will be sent once for every trigger event. </li>
</ul>
</dd>
<dd>
Due to hardware limitation, in non-cyclic mode, the channel will idle with the first sample of the next buffer. </dd>
<dd>
Only available from firmware v0.33. </dd></dl>

</div>
</div>
<a id="ga65ac70a9f0efd26bc46f01a8c6e7f371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65ac70a9f0efd26bc46f01a8c6e7f371">&#9670;&nbsp;</a></span>setCyclic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::setCyclic </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>en</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the cyclic mode for all digital channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">en</td><td>If true, enable cyclic mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EXC_OUT_OF_RANGE</td><td>No such channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8fabc8b94b3874d6aff5a573fa4de5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fabc8b94b3874d6aff5a573fa4de5d5">&#9670;&nbsp;</a></span>setCyclic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::setCyclic </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable or disable the cyclic mode for all digital channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The index corresponding to the channel </td></tr>
    <tr><td class="paramname">en</td><td>If true, enable cyclic mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EXC_OUT_OF_RANGE</td><td>No such channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga054b4fc523c5b5fdf5f39f5b14ae94e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga054b4fc523c5b5fdf5f39f5b14ae94e7">&#9670;&nbsp;</a></span>setKernelBuffersCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::setKernelBuffersCount </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chnIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the kernel buffers to a specific value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chnIdx</td><td>The index corresponding to the channel </td></tr>
    <tr><td class="paramname">count</td><td>the number of kernel buffers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe34faa439ccf011673c5f1ddcc387e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe34faa439ccf011673c5f1ddcc387e7">&#9670;&nbsp;</a></span>setOversamplingRatio() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;int&gt; libm2k::analog::M2kAnalogOut::setOversamplingRatio </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>oversampling_ratio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the oversampling ratio for each channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oversampling_ratio</td><td>A list containing the ratios for each channel (as integers) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list containing the oversampling ratio value for each channel </dd></dl>

</div>
</div>
<a id="ga2b50d86fc115feb46fdfe43ca2a1cb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b50d86fc115feb46fdfe43ca2a1cb3b">&#9670;&nbsp;</a></span>setOversamplingRatio() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int libm2k::analog::M2kAnalogOut::setOversamplingRatio </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>oversampling_ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the oversampling ratio for the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The index corresponding to the channel </td></tr>
    <tr><td class="paramname">oversampling_ratio</td><td>Integer value to set the oversampling ratio to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current oversampling ratio value </dd></dl>

</div>
</div>
<a id="gab34bd111c55ed24ee4d49e26311794c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab34bd111c55ed24ee4d49e26311794c4">&#9670;&nbsp;</a></span>setSampleRate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;double&gt; libm2k::analog::M2kAnalogOut::setSampleRate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>samplerates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the sample rate for both channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samplerates</td><td>A list containing the sample rates of each channel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list containing the previously set sample rates </dd></dl>

</div>
</div>
<a id="ga84ce57f056e85fe9d58067fb8ceca21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84ce57f056e85fe9d58067fb8ceca21f">&#9670;&nbsp;</a></span>setSampleRate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double libm2k::analog::M2kAnalogOut::setSampleRate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>samplerate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the sample rate for the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The index corresponding to the channel </td></tr>
    <tr><td class="paramname">samplerate</td><td>A double value to set the sample rate to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the sample rate </dd></dl>

</div>
</div>
<a id="gafe266e2ff3c51fcc6878e7e487e2b010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe266e2ff3c51fcc6878e7e487e2b010">&#9670;&nbsp;</a></span>setVoltage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned short libm2k::analog::M2kAnalogOut::setVoltage </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>volts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the voltage output of the DAC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn_idx</td><td>- unsigned int representing the index of the channel </td></tr>
    <tr><td class="paramname">volts</td><td>- actual value to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In scenarios where the DMA is not active, such as when an output buffer is destroyed, the DAC will revert to using the raw value set by this function. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned short - the corresponding raw value for the given voltage </dd></dl>

</div>
</div>
<a id="gab436c577c151a246305a83f73953f124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab436c577c151a246305a83f73953f124">&#9670;&nbsp;</a></span>setVoltageRaw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned short libm2k::analog::M2kAnalogOut::setVoltageRaw </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>raw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the raw output of the DAC channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn_idx</td><td>- unsigned int representing the index of the channel </td></tr>
    <tr><td class="paramname">raw</td><td>- actual value to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In scenarios where the DMA is not active, such as when an output buffer is destroyed, the DAC will revert to using the raw value set by this function. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned short - the value set in the raw attribute </dd></dl>

</div>
</div>
<a id="ga8fb08074cdda7f6fb407a2dfc0193efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fb08074cdda7f6fb407a2dfc0193efb">&#9670;&nbsp;</a></span>stop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop all channels from sending the signals. </p>
<dl class="section note"><dt>Note</dt><dd>Both DACs will be powered down </dd></dl>

</div>
</div>
<a id="ga0087d48359470e8d7f0aaffe42b485e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0087d48359470e8d7f0aaffe42b485e1">&#9670;&nbsp;</a></span>stop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void libm2k::analog::M2kAnalogOut::stop </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the given channels from sending the signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chn</td><td>The index corresponding to the channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The corresponding DAC will be powered down </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EXC_OUT_OF_RANGE</td><td>No such channel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
